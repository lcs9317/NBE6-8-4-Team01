name: PR → Auto-create/update linked Issue (idempotent)

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

permissions:
  contents: read
  pull-requests: write
  issues: write

env:
  PROJECT_OWNER: prgrms-be-devcourse
  PROJECT_NUMBER: 269

concurrency:
  group: pr-auto-issue-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  ensure-issue:
    runs-on: ubuntu-latest
    steps:
      - name: Create or update an issue from PR and link back (idempotent)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.PROJECTS_TOKEN }}   # PAT(Projects write + read:org) 권장
          script: |
            const pr    = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // -------------------------- utils --------------------------
            const hasClosingFor = (body, n) =>
              new RegExp(`\\b(?:close[sd]?|fixe?[sd]?|resolve[sd]?)\\s+#${n}\\b`, 'i').test(body || '');

            // 기존 Closes를 삭제하지 않고 필요한 경우에만 한 줄 추가 + 마커 추가
            const addOrAppendAutoLink = (body, n) => {
              const prMarkerRe = /<!--\\s*auto-linked-issue:\\d+\\s*-->/;
              const hasCloseForN = new RegExp(`\\b(?:close[sd]?|fixe?[sd]?|resolve[sd]?)\\s+#${n}\\b`, 'i').test(body || '');
              const hasMarker    = prMarkerRe.test(body || '');
              let out = (body || '').trim();
              if (!hasCloseForN) out = `${out}\n\nCloses #${n}`.trim();
              if (!hasMarker)    out = `${out}\n<!-- auto-linked-issue:${n} -->`.trim();
              return out;
            };

            const ensureLabels = async (names) => {
              for (const name of names) {
                try { await github.rest.issues.getLabel({ owner, repo, name }); }
                catch { await github.rest.issues.createLabel({ owner, repo, name, color: "ededed" }); }
              }
            };

            const addLabelsIfMissing = async (issue_number, labels) => {
              if (!labels || !labels.length) return;
              try {
                await github.rest.issues.addLabels({ owner, repo, issue_number, labels });
              } catch (e) {
                core.info(`addLabels skipped: ${e.message}`);
              }
            };

            // ------------------- 템플릿 섹션 파싱(관대) -------------------
            const body0 = pr.body || "";
            const grab = (patterns) => {
              for (const p of patterns) {
                const re = new RegExp(`^##\\s*${p}(?:[^\\n]*)?\\n([\\s\\S]*?)(?=^##\\s|\\Z)`, 'mi');
                const m = body0.match(re);
                if (m) return m[1].trim();
              }
              return "";
            };
            const WHATWHY   = grab(["무엇을\\s*/\\s*왜"]);
            const DETAILS   = grab(["어떻게\\(요약\\)", "핵심 변경점 요약"]);
            const CHECKLIST = grab(["체크리스트"]);
            const PROOF     = grab(["스크린샷/증빙\\(선택\\)", "스크린샷/증빙\\(필요 시\\)", "스크린샷/증빙"]);

            // [TYPE]: 제목 → TYPE/Subject
            const typeMatch = (pr.title || "").match(/^\\s*\\[(FEAT|FIX|REFACTOR|COMMENT|STYLE|TEST|CHORE|INIT)\\]\\s*:\\s*/i);
            const TYPE     = (typeMatch ? typeMatch[1] : "CHORE").toUpperCase();
            const SUBJECT  = (pr.title || "").replace(/^\\s*\\[[^\\]]+\\]\\s*:\\s*/,'').trim() || `PR #${pr.number}`;

            // ------------------ 0) PR 본문 마커 체크 ----------------------
            const prMarkerRe = /<!--\\s*auto-linked-issue:(\\d+)\\s*-->/;
            let linkedIssueNo = null;
            let respectManualClose = false; // 수동 Closes 존중 플래그

            const mm = body0.match(prMarkerRe);
            if (mm) {
              const n = Number(mm[1]);
              try { await github.rest.issues.get({ owner, repo, issue_number: n }); linkedIssueNo = n; } catch {}
            }

            // --------------- 1) 수동 Closes #N 우선 존중 -----------------
            if (!linkedIssueNo) {
              const manual = (pr.body || '').match(/\\b(?:close[sd]?|fixe?[sd]?|resolve[sd]?)\\s+#(\\d+)\\b/i);
              if (manual) {
                const n = Number(manual[1]);
                try {
                  await github.rest.issues.get({ owner, repo, issue_number: n });
                  linkedIssueNo = n;
                  respectManualClose = true;
                  core.info(`Respecting manual close reference -> #${linkedIssueNo}`);
                } catch {}
              }
            }

            // --------- 2) 이전에 자동 생성된 이슈(본문 시그널) 탐색 ----------
            if (!linkedIssueNo) {
              const q = `repo:${owner}/${repo} is:issue is:open in:body "Auto-created for PR #${pr.number}" label:auto`;
              const found = await github.rest.search.issuesAndPullRequests({ q });
              if (found.data.items.length > 0) linkedIssueNo = found.data.items[0].number;
            }

            // --------- 3) 동일 제목으로 열린 일반 이슈(라벨 제한 X) ----------
            if (!linkedIssueNo) {
              const t = `[${TYPE}]: ${SUBJECT}`.replace(/\\"/g, '\\\\"');
              const q = `repo:${owner}/${repo} is:issue is:open in:title "${t}"`;
              const foundByTitle = await github.rest.search.issuesAndPullRequests({ q });
              if (foundByTitle.data.items.length === 1) {
                linkedIssueNo = foundByTitle.data.items[0].number;
                core.info(`Found issue by title -> #${linkedIssueNo}`);
              }
            }

            // ------------------ 이슈 본문/제목 템플릿 ----------------------
            const issueTitle = `[${TYPE}]: ${SUBJECT}`;
            const issueBody = [
              `### 변경 유형 (Type)`,
              TYPE || "_(미입력)_",
              ``,
              `### 제목(Subject)`,
              SUBJECT || "_(미입력)_",
              ``,
              `### 무엇을 / 왜`,
              WHATWHY || "_(PR 본문에 항목 없음)_",
              ``,
              `### 상세 설명(필요 시)`,
              DETAILS || "_(생략)_",
              ``,
              `### ToDoList`,
              (CHECKLIST && CHECKLIST.trim()) || "- [ ] (작성 필요)",
              ``,
              `### 비고(스크린샷/참고자료)`,
              PROOF || "_(생략)_",
              ``,
              `---`,
              `Auto-created for PR #${pr.number}`,
              `<!-- auto-issue-for-pr:${pr.number} -->`
            ].join("\\n");

            // ------------------ 4) 생성 또는 업데이트 ----------------------
            await ensureLabels(["auto", "needs-triage", TYPE]);

            let issueNumber;
            let createdNew = false;

            if (linkedIssueNo) {
              // 기존 이슈 업데이트(라벨은 덮어쓰지 않고 addLabels로 보강)
              issueNumber = linkedIssueNo;
              await github.rest.issues.update({
                owner, repo, issue_number: issueNumber,
                title: issueTitle, body: issueBody
              });
              await addLabelsIfMissing(issueNumber, ["needs-triage", TYPE]); // auto는 기존 수동 이슈에 강제하지 않음
            } else {
              // 새로 생성: auto 라벨 포함
              const created = await github.rest.issues.create({
                owner, repo, title: issueTitle, body: issueBody, labels: ["auto", "needs-triage", TYPE]
              });
              issueNumber = created.data.number;
              createdNew = true;
            }

            // --------- 5) PR 본문 링크/마커(덮어쓰기 금지) -------------------
            const current = pr.body || "";
            if (respectManualClose) {
              // 수동 Closes 존중: 본문은 그대로, 마커만 없으면 추가
              if (!/<!--\\s*auto-linked-issue:\\d+\\s*-->/.test(current)) {
                const updated = `${current.trim()}\\n\\n<!-- auto-linked-issue:${issueNumber} -->`.trim();
                await github.rest.pulls.update({ owner, repo, pull_number: pr.number, body: updated });
              }
            } else {
              // 제목매칭/자동생성: 필요 시에만 추가
              const updated = addOrAppendAutoLink(current, issueNumber);
              if (updated !== current) {
                await github.rest.pulls.update({ owner, repo, pull_number: pr.number, body: updated });
              }
            }

            core.info(`Linked PR #${pr.number} ↔ Issue #${issueNumber}`);

            // -------------------- 6) Assignee 자동 지정 --------------------
            try {
              const author = pr?.user?.login;
              if (author) {
                try {
                  await github.rest.issues.addAssignees({ owner, repo, issue_number: issueNumber, assignees: [author] });
                  core.info(`Issue #${issueNumber} assignee: ${author}`);
                } catch (e) { core.info(`Skip assigning issue: ${e.message}`); }
                try {
                  await github.rest.issues.addAssignees({ owner, repo, issue_number: pr.number, assignees: [author] });
                  core.info(`PR #${pr.number} assignee: ${author}`);
                } catch (e) { core.info(`Skip assigning PR: ${e.message}`); }
              }
            } catch (e) { core.info(`Assign block failed: ${e.message}`); }

            // ---------------- 7) Projects(v2) 연동 및 Status ----------------
            try {
              const login  = process.env.PROJECT_OWNER || context.repo.owner;
              const number = Number(process.env.PROJECT_NUMBER || 1);

              // 7-1) Project ID 조회 (org → user 순차 시도)
              let projectId = null;
              try {
                const r = await github.graphql(
                  `query($login:String!,$number:Int!){
                    organization(login:$login){ projectV2(number:$number){ id title } }
                  }`, { login, number }
                );
                projectId = r?.organization?.projectV2?.id || null;
              } catch (e) { core.info("Projects: org lookup failed → " + e.message); }
              if (!projectId) {
                try {
                  const r2 = await github.graphql(
                    `query($login:String!,$number:Int!){
                      user(login:$login){ projectV2(number:$number){ id title } }
                    }`, { login, number }
                  );
                  projectId = r2?.user?.projectV2?.id || null;
                } catch (e) { core.info("Projects: user lookup failed → " + e.message); }
              }
              if (!projectId) { core.info(`Projects: projectId not found for ${login}#${number}`); return; }

              // 7-2) 노드 ID
              const [iss, prr] = await Promise.all([
                github.rest.issues.get({ owner, repo, issue_number: issueNumber }),
                github.rest.pulls.get({ owner, repo, pull_number: pr.number })
              ]);
              const issueNodeId = iss.data.node_id;
              const prNodeId    = prr.data.node_id;

              // 7-3) 아이템 추가(멱등)
              const listQ = `
                query($projectId:ID!, $after:String) {
                  node(id:$projectId) {
                    ... on ProjectV2 {
                      items(first:50, after:$after) {
                        pageInfo { hasNextPage endCursor }
                        nodes { id content { ... on Issue { id } ... on PullRequest { id } } }
                      }
                    }
                  }
                }`;
              const addM = `
                mutation($projectId:ID!, $contentId:ID!) {
                  addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) {
                    item { id }
                  }
                }`;
              const addIfMissing = async (contentId) => {
                let cursor = null, found = null;
                while (true) {
                  const r = await github.graphql(listQ, { projectId, after: cursor });
                  const items = r?.node?.items?.nodes || [];
                  for (const it of items) if (it?.content?.id === contentId) { found = it.id; break; }
                  if (found || !r?.node?.items?.pageInfo?.hasNextPage) break;
                  cursor = r.node.items.pageInfo.endCursor;
                }
                if (found) return found;
                const a = await github.graphql(addM, { projectId, contentId });
                return a?.addProjectV2ItemById?.item?.id || null;
              };
              const issueItemId = await addIfMissing(issueNodeId);
              const prItemId    = await addIfMissing(prNodeId);
              core.info(`Projects: linked (issueItem=${issueItemId}, prItem=${prItemId})`);

              // 7-4) Status 설정
              const desiredStatus = pr.draft ? "Ready" : "In progress";
              const fieldsQ = `
                query($projectId:ID!) {
                  node(id:$projectId) {
                    ... on ProjectV2 {
                      fields(first:50) {
                        nodes {
                          ... on ProjectV2FieldCommon { id name dataType }
                          ... on ProjectV2SingleSelectField { id name options { id name } }
                        }
                      }
                    }
                  }
                }`;
              const fr = await github.graphql(fieldsQ, { projectId });
              const fields = fr?.node?.fields?.nodes || [];
              const statusField = fields.find(f => f.name === "Status" && f.options);
              if (statusField) {
                const opt = statusField.options.find(o => o.name === desiredStatus);
                if (opt) {
                  const setM = `
                    mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optId:String!) {
                      updateProjectV2ItemFieldValue(input:{
                        projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                        value:{ singleSelectOptionId:$optId }
                      }) { projectV2Item { id } }
                    }`;
                  if (issueItemId) await github.graphql(setM, { projectId, itemId: issueItemId, fieldId: statusField.id, optId: opt.id });
                  if (prItemId)    await github.graphql(setM, { projectId, itemId: prItemId,    fieldId: statusField.id, optId: opt.id });
                  core.info(`Projects: set Status="${desiredStatus}"`);
                } else {
                  core.info(`Projects: Status option "${desiredStatus}" not found.`);
                }
              } else {
                core.info('Projects: "Status" field not found.');
              }

              // 7-5) Roadmap: Start date = PR 생성일, "비어 있을 때만" 세팅
              try {
                const startFieldName = "Start date";
                const startDate = (pr.created_at || new Date().toISOString()).substring(0,10);

                const getDateFieldValue = async (itemId, fieldName) => {
                  if (!itemId) return null;
                  const q = `
                    query($itemId:ID!) {
                      node(id:$itemId) {
                        ... on ProjectV2Item {
                          fieldValues(first:50) {
                            nodes {
                              ... on ProjectV2ItemFieldDateValue {
                                date
                                field { ... on ProjectV2FieldCommon { id name } }
                              }
                            }
                          }
                        }
                      }
                    }`;
                  const r = await github.graphql(q, { itemId });
                  const nodes = r?.node?.fieldValues?.nodes || [];
                  const hit = nodes.find(n => n?.field?.name === fieldName);
                  return hit?.date || null;
                };

                const setDate = async (itemId) => {
                  if (!itemId) return;
                  const existing = await getDateFieldValue(itemId, startFieldName);
                  if (existing) { core.info(`Skip Start date (already set: ${existing})`); return; }

                  // 필드 ID 조회
                  const fieldsQ2 = `
                    query($projectId:ID!) {
                      node(id:$projectId) {
                        ... on ProjectV2 {
                          fields(first:50) { nodes { ... on ProjectV2FieldCommon { id name dataType } } }
                        }
                      }
                    }`;
                  const fr2 = await github.graphql(fieldsQ2, { projectId });
                  const fields2 = fr2?.node?.fields?.nodes || [];
                  const startFieldId = fields2.find(f => f.name === startFieldName && f.dataType === "DATE")?.id;
                  if (!startFieldId) { core.info(`No "${startFieldName}" field`); return; }

                  const mut = `
                    mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $d:Date!) {
                      updateProjectV2ItemFieldValue(input:{
                        projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                        value:{ date:$d }
                      }) { projectV2Item { id } }
                    }`;
                  await github.graphql(mut, { projectId, itemId, fieldId: startFieldId, d: startDate });
                  core.info(`Set Start date: ${startDate}`);
                };

                await setDate(issueItemId);
                await setDate(prItemId);
              } catch (e) {
                core.info("Roadmap start date skipped: " + e.message);
              }
            } catch (e) {
              core.info("Projects link/status skipped: " + e.message);
            }
